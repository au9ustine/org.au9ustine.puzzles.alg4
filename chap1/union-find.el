(require 'cl)

(defun make-uf (N)
  (vconcat (loop for i from 0 to (- N 1) collect i)))
(defun uf-find (g p)
  (aref g p))
(defun uf-connected (g p q)
  (= (uf-find g p) (uf-find g q)))
(defun uf-union (g p q)
  (let* ((p-id (uf-find g p))
         (q-id (uf-find g q)))
    (unless (equalp p-id q-id)
        (progn
          (dotimes (i (length g))
            (if (= (aref g i) p-id)
                (aset g i q-id)))
          (decf N)))))
(defun uf-quick-find (g p)
  (while (not (equalp p (aref g p)))
    (setq p (aref g p)))
  p)

(defun uf-quick-union (g p q)
  (let* ((p-root (uf-quick-find g p))
         (q-root (uf-quick-find g q)))
    (unless (equalp p-root q-root)
      (progn
        (aset g p-root q-root)
        (decf N)))))
           
;; Test
(progn
  (setf N 10)
  (setf my-g (make-uf 10))
  (dolist (conn '((4 . 3)
                  (3 . 8)
                  (6 . 5)
                  (9 . 4)
                  (2 . 1)
                  (8 . 9)
                  (5 . 0)
                  (7 . 2)
                  (6 . 1)
                  (1 . 0)
                  (6 . 7)))
    (uf-quick-union my-g (car conn) (cdr conn)))
   (list my-g N))
;; ([1 1 1 8 3 0 5 1 8 8] 2)
